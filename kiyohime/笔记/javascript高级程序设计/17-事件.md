## 事件

JavaScript 与 HTML 的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。在传统软件工程领域，这个模型叫“观察者模式”，其能够做到页面行为（在 JavaScript 中定义）与页面展示（在 HTML 和 CSS 中定义）的分离。

事件最早是在 IE3 和 Netscape Navigator 2 中出现的，当时的用意是把某些表单处理工作从服务器转移到浏览器上来。到了 IE4 和 Netscape Navigator 3 发布的时候，这两家浏览器都提供了类似但又不同的 API，而且持续了好几代。DOM2 开始尝试以符合逻辑的方式来标准化 DOM 事件 API。目前所有现代浏览器都实现了 DOM2 Events 的核心部分。IE8 是最后一个使用专有事件系统的主流浏览器。

浏览器的事件系统非常复杂。即使所有主流浏览器都实现了 DOM2 Events，规范也没有涵盖所有的事件类型。BOM 也支持事件，这些事件与 DOM 事件之间的关系由于长期以来缺乏文档，经常容易被混淆（HTML5 已经致力于明确这些关系）。而 DOM3 新增的事件 API 又让这些问题进一步复杂化了。根据具体的需求不同，使用事件可能会相对简单，也可能会非常复杂。但无论如何，理解其中的核心概念还是最重要的。

1.  事件流
    在第四代 Web 浏览器（IE4 和 Netscape Communicator 4）开始开发时，开发团队碰到了一个有意思的问题：页面哪个部分拥有特定的事件呢？要理解这个问题，可以在一张纸上画几个同心圆。把手指放到圆心上，则手指不仅是在一个圆圈里，而且是在所有的圆圈里。两家浏览器的开发团队都是以同样的方式看待浏览器事件的。当你点击一个按钮时，实际上不光点击了这个按钮，还点击了它的容器以及整个页面。

    事件流描述了页面接收事件的顺序。结果非常有意思，IE 和 Netscape 开发团队提出了几乎完全相反的事件流方案。IE 将支持事件冒泡流，而 Netscape Communicator 将支持事件捕获流。

    1. 事件冒泡
       IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。

    2. 事件捕获
       Netscape Communicator 团队提出了另一种名为事件捕获的事件流。事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。

    3. DOM 事件流
       DOM2 Events 规范规定事件流分为 3 个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。

2.  事件处理程序
    事件意味着用户或浏览器执行的某种动作。比如，单击（click）、加载（load）、鼠标悬停（mouseover）。为响应事件而调用的函数被称为事件处理程序（或事件监听器）。事件处理程序的名字以"on"开头，因此 click 事件的处理程序叫作 onclick，而 load 事件的处理程序叫作 onload。有很多方式可以指定事件处理程序。

    1. HTML 事件处理程序
       特定元素支持的每个事件都可以使用事件处理程序的名字以 HTML 属性的形式来指定。此时属性的值必须是能够执行的 JavaScript 代码。例如，要在按钮被点击时执行某些 JavaScript 代码，可以使用以下 HTML 属性：

       ```html
       <input type="button" value="Click Me" onclick="console.log('Clicked')" />
       ```

       点击这个按钮后，控制台会输出一条消息。这种交互能力是通过为 onclick 属性指定 JavaScript 代码值来实现的。注意，因为属性的值是 JavaScript 代码，所以不能在未经转义的情况下使用 HTML 语法字符，比如和号（&）、双引号（"）、小于号（<）和大于号（>）。此时，为了避免使用 HTML 实体，可以使用单引号代替双引号。

    2. DOM0 事件处理程序
       在 JavaScript 中指定事件处理程序的传统方式是把一个函数赋值给（DOM 元素的）一个事件处理程序属性。这也是在第四代 Web 浏览器中开始支持的事件处理程序赋值方法，直到现在所有现代浏览器仍然都支持此方法，主要原因是简单。要使用 JavaScript 指定事件处理程序，必须先取得要操作对象的引用。

       每个元素（包括 window 和 document）都有通常小写的事件处理程序属性，比如 onclick。只要把这个属性赋值为一个函数即可。

    3. DOM2 事件处理程序
       DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：addEventListener()和 removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。

    4. IE 事件处理程序
       IE 实现了与 DOM 类似的方法，即 attachEvent()和 detachEvent()。这两个方法接收两个同样的参数：事件处理程序的名字和事件处理函数。因为 IE8 及更早版本只支持事件冒泡，所以使用 attachEvent()添加的事件处理程序会添加到冒泡阶段。

    5. 跨浏览器事件处理程序
       为了以跨浏览器兼容的方式处理事件，很多开发者会选择使用一个 JavaScript 库，其中抽象了不同浏览器的差异。有些开发者也可能会自己编写代码，以便使用最合适的事件处理手段。自己编写跨浏览器事件处理代码也很简单，主要依赖能力检测。要确保事件处理代码具有最大兼容性，只需要让代码在冒泡阶段运行即可。

3.  事件对象
    在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 event 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。例如，鼠标操作导致的事件会生成鼠标位置信息，而键盘操作导致的事件会生成与被按下的键有关的信息。所有浏览器都支持这个 event 对象，尽管支持方式不同。

    1. DOM 事件对象
       在 DOM 合规的浏览器中，event 对象是传给事件处理程序的唯一参数。不管以哪种方式（DOM0 或 DOM2）指定事件处理程序，都会传入这个 event 对象。

       在事件处理程序内部，this 对象始终等于 currentTarget 的值，而 target 只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标，则 this、currentTarget 和 target 的值是一样的。

       preventDefault()方法用于阻止特定事件的默认动作。比如，链接的默认行为就是在被单击时导航到 href 属性指定的 URL。如果想阻止这个导航行为，可以在 onclick 事件处理程序中取消，

       stopPropagation()方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡。例如，直接添加到按钮的事件处理程序中调用 stopPropagation()，可以阻止 document.body 上注册的事件处理程序执行。

       eventPhase 属性可用于确定事件流当前所处的阶段。如果事件处理程序在捕获阶段被调用，则 eventPhase 等于 1；如果事件处理程序在目标上被调用，则 eventPhase 等于 2；如果事件处理程序在冒泡阶段被调用，则 eventPhase 等于 3。不过要注意的是，虽然“到达目标”是在冒泡阶段发生的，但其 eventPhase 仍然等于 2。

    2. IE 事件对象
       与 DOM 事件对象不同， IE 事件对象可以基于事件处理程序被指定的方式以不同方式来访问。如果事件处理程序是使用 DOM0 方式指定的，则 event 对象只是 window 对象的一个属性。不过，如果事件处理程序是使用 attachEvent()指定的，则 event 对象会作为唯一的参数传给处理函数。

    3. 跨浏览器事件对象
       虽然 DOM 和 IE 的事件对象并不相同，但它们有足够的相似性可以实现跨浏览器方案。DOM 事件对象中包含 IE 事件对象的所有信息和能力，只是形式不同。这些共性可让两种事件模型之间的映射成为可能。

4.  事件类型
    Web 浏览器中可以发生很多种事件。如前所述，所发生事件的类型决定了事件对象中会保存什么信息。DOM3 Events 定义了如下事件类型。

        - 用户界面事件（UIEvent）：涉及与 BOM 交互的通用浏览器事件。
        - 焦点事件（FocusEvent）：在元素获得和失去焦点时触发。
        - 鼠标事件（MouseEvent）：使用鼠标在页面上执行某些操作时触发。
        - 滚轮事件（WheelEvent）：使用鼠标滚轮（或类似设备）时触发。
        - 输入事件（InputEvent）：向文档中输入文本时触发。
        - 键盘事件（KeyboardEvent）：使用键盘在页面上执行某些操作时触发。
        - 合成事件（CompositionEvent）：在使用某种 IME（Input Method Editor，输入法编辑器）输入字符时触发。

        除了这些事件类型之外，HTML5 还定义了另一组事件，而浏览器通常在 DOM 和 BOM 上实现专有事件。这些专有事件基本上都是根据开发者需求而不是按照规范增加的，因此不同浏览器的实现可能不同。

        DOM3 Events 在 DOM2 Events 基础上重新定义了事件，并增加了新的事件类型。所有主流浏览器都支持 DOM2 Events 和 DOM3 Events。

        1. 用户界面事件
           用户界面事件或 UI 事件不一定跟用户操作有关。这类事件在 DOM 规范出现之前就已经以某种形式存在了，保留它们是为了向后兼容。UI 事件主要有以下几种。

           - DOMActivate：元素被用户通过鼠标或键盘操作激活时触发（比 click 或 keydown 更通用）。这个事件在 DOM3 Events 中已经废弃。因为浏览器实现之间存在差异，所以不要使用它。
           - load：在 window 上当页面加载完成后触发，在窗套（< frameset>）上当所有窗格（< frame>）都加载完成后触发，在< img>元素上当图片加载完成后触发，在< object>元素上当相应对象加载完成后触发。
           - unload：在 window 上当页面完全卸载后触发，在窗套上当所有窗格都卸载完成后触发，在< object>元素上当相应对象卸载完成后触发。
           - abort：在< object>元素上当相应对象加载完成前被用户提前终止下载时触发。
           - error：在 window 上当 JavaScript 报错时触发，在< img>元素上当无法加载指定图片时触发，在< object>元素上当无法加载相应对象时触发，在窗套上当一个或多个窗格无法完成加载时触发。
           - select：在文本框（< input>或 textarea）上当用户选择了一个或多个字符时触发。
           - resize：在 window 或窗格上当窗口或窗格被缩放时触发。
           - scroll：当用户滚动包含滚动条的元素时在元素上触发。< body>元素包含已加载页面的滚动条。

           1. load 事件
              load 事件可能是 JavaScript 中最常用的事件。在 window 对象上，load 事件会在整个页面（包括所有外部资源如图片、JavaScript 文件和 CSS 文件）加载完成后触发。可以通过两种方式指定 load 事件处理程序。

              图片上也会触发 load 事件，包括 DOM 中的图片和非 DOM 中的图片。可以在 HTML 中直接给< img>元素的 onload 属性指定事件处理程序。

              同样的技术也适用于 DOM0 的 Image 对象。在 DOM 出现之前，客户端都使用 Image 对象预先加载图片。可以像使用前面（通过 createElement()方法创建）的< img>元素一样使用 Image 对象，只是不能把后者添加到 DOM 树。

              还有一些元素也以非标准的方式支持 load 事件。< script>元素会在 JavaScript 文件加载完成后触发 load 事件，从而可以动态检测。与图片不同，要下载 JavaScript 文件必须同时指定 src 属性并把< script>元素添加到文档中。因此指定事件处理程序和指定 src 属性的顺序在这里并不重要。下面的代码展示了如何给动态创建的< script>元素指定事件处理程序：

              ```javascript
                window.addEventListener("load", () => {
                  let script = document.createElement("script");
                  script.addEventListener("load", (event) => {
                  console.log("Loaded");
                  });
                  script.src = "example.js";
                  document.body.appendChild(script);
                  });
              ```

            2. unload事件
               与load事件相对的是unload事件，unload事件会在文档卸载完成后触发。unload事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏。与load事件类似，unload事件处理程序也有两种指定方式。

            3. resize事件
               当浏览器窗口被缩放到新高度或宽度时，会触发resize事件。这个事件在window上触发，因此可以通过JavaScript在window上或者为<body>元素添加onresize属性来指定事件处理程序。

            4. scroll事件
               虽然scroll事件发生在window上，但实际上反映的是页面中相应元素的变化。在混杂模式下，可以通过<body>元素检测scrollLeft和scrollTop属性的变化。而在标准模式下，这些变化在除早期版的Safari之外的所有浏览器中都发生在<html>元素上（早期版的Safari在<body>上跟踪滚动位置）。

         2. 焦点事件
            焦点事件在页面元素获得或失去焦点时触发。这些事件可以与document.hasFocus()和document.activeElement一起为开发者提供用户在页面中导航的信息。焦点事件有以下6种。

            - blur：当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。
            - DOMFocusIn：当元素获得焦点时触发。这个事件是focus的冒泡版。Opera是唯一支持这个事件的主流浏览器。DOM3 Events废弃了DOMFocusIn，推荐focusin。
            - DOMFocusOut：当元素失去焦点时触发。这个事件是blur的通用版。Opera是唯一支持这个事件的主流浏览器。DOM3 Events废弃了DOMFocusOut，推荐focusout。
            - focus：当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。
            - focusin：当元素获得焦点时触发。这个事件是focus的冒泡版。
            - focusout：当元素失去焦点时触发。这个事件是blur的通用版。

            焦点事件中的两个主要事件是focus和blur，这两个事件在JavaScript早期就得到了浏览器支持。它们最大的问题是不冒泡。这导致IE后来又增加了focusin和focusout，Opera又增加了DOMFocusIn和DOMFocusOut。IE新增的这两个事件已经被DOM3 Events标准化。

            当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。

            (1) focuscout在失去焦点的元素上触发。

            (2) focusin 在获得焦点的元素上触发。

            (3) blur 在失去焦点的元素上触发。

            (4) DOMFocusOut 在失去焦点的元素上触发。

            (5) focus 在获得焦点的元素上触发。

            (6) DOMFocusIn 在获得焦点的元素上触发。

            其中，blur、DOMFocusOut 和 focusout 的事件目标是失去焦点的元素，而 focus、DOMFocusIn 和 focusin 的事件目标是获得焦点的元素。

         3. 鼠标和滚轮事件
            鼠标事件是Web开发中最常用的一组事件，这是因为鼠标是用户的主要定位设备。DOM3 Events定义了9种鼠标事件。

            - click：在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发onclick事件处理程序。
            - dblclick：在用户双击鼠标主键（通常是左键）时触发。这个事件不是在DOM2 Events中定义的，但得到了很好的支持，DOM3 Events将其进行了标准化。
            - mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。
            - mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseenter事件不是在DOM2 Events中定义的，而是DOM3 Events中新增的事件。
            - mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseleave事件不是在DOM2 Events中定义的，而是DOM3 Events中新增的事件。
            - mousemove：在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发。
            - mouseout：在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。
            - mouseover：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发。
            - mouseup：在用户释放鼠标键时触发。这个事件不能通过键盘触发。

            页面中的所有元素都支持鼠标事件。除了mouseenter和mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。

            由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。

            比如，click事件触发的前提是mousedown事件触发后，紧接着又在同一个元素上触发了mouseup事件。如果mousedown和mouseup中的任意一个事件被取消，那么click事件就不会触发。类似地，两次连续的click事件会导致dblclick事件触发。只要有任何逻辑阻止了这两个click事件发生（比如取消其中一个click事件或者取消mousedown或mouseup事件中的任一个），dblclick事件就不会发生。这4个事件永远会按照如下顺序触发：

            (1) mousedown

            (2) mouseup

            (3) click

            (4) mousedown

            (5) mouseup

            (6) click

            (7) dblclick

            click和dblclick在触发前都依赖其他事件触发，mousedown和mouseup则不会受其他事件影响。

            鼠标事件还有一个名为滚轮事件的子类别。滚轮事件只有一个事件mousewheel，反映的是鼠标滚轮或带滚轮的类似设备上滚轮的交互。

            1. 客户端坐标
               鼠标事件都是在浏览器视口中的某个位置上发生的。这些信息被保存在event对象的clientX和clientY属性中。这两个属性表示事件发生时鼠标光标在视口中的坐标，所有浏览器都支持。

            2. 页面坐标
               客户端坐标是事件发生时鼠标光标在客户端视口中的坐标，而页面坐标是事件发生时鼠标光标在页面上的坐标，通过event对象的pageX和pageY可以获取。这两个属性表示鼠标光标在页面上的位置，因此反映的是光标到页面而非视口左边与上边的距离。

            3. 屏幕坐标
               鼠标事件不仅是在浏览器窗口中发生的，也是在整个屏幕上发生的。可以通过event对象的screenX和screenY属性获取鼠标光标在屏幕上的坐标。

            4. 修饰键
               虽然鼠标事件主要是通过鼠标触发的，但有时候要确定用户想实现的操作，还要考虑键盘按键的状态。键盘上的修饰键Shift、Ctrl、Alt和Meta经常用于修改鼠标事件的行为。DOM规定了4个属性来表示这几个修饰键的状态：shiftKey、ctrlKey、altKey和metaKey。这几属性会在各自对应的修饰键被按下时包含布尔值true，没有被按下时包含false。在鼠标事件发生的，可以通过这几个属性来检测修饰键是否被按下。

            5. 相关元素
               对mouseover和mouseout事件而言，还存在与事件相关的其他元素。这两个事件都涉及从一个元素的边界之内把光标移到另一个元素的边界之内。对mouseover事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。类似地，对mouseout事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。

               DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只有在mouseover和mouseout事件发生时才包含值，其他所有事件的这个属性的值都是null。IE8及更早版本不支持relatedTarget属性，但提供了其他的可以访问到相关元素的属性。在mouseover事件触发时，IE会提供fromElement属性，其中包含相关元素。而在mouseout事件触发时，IE会提供toElement属性，其中包含相关元素。

            6. 鼠标按键
               只有在元素上单击鼠标主键（或按下键盘上的回车键）时click事件才会触发，因此按键信息并不是必需的。对mousedown和mouseup事件来说，event对象上会有一个button属性，表示按下或释放的是哪个按键。DOM为这个button属性定义了3个值：0表示鼠标主键、1表示鼠标中键（通常也是滚轮键）、2表示鼠标副键。按照惯例，鼠标主键通常是左边的按键，副键通常是右边的按键。
               IE8及更早版本也提供了button属性，但这个属性的值与前面说的完全不同：
               - 0，表示没有按下任何键；
               - 1，表示按下鼠标主键；
               - 2，表示按下鼠标副键；
               - 3，表示同时按下鼠标主键、副键；
               - 4，表示按下鼠标中键；
               - 5，表示同时按下鼠标主键和中键；
               - 6，表示同时按下鼠标副键和中键；
               - 7，表示同时按下3个键。

               很显然，DOM定义的button属性比IE这一套更简单也更有用，毕竟同时按多个鼠标键的情况很少见。为此，实践中基本上都以DOM的button属性为准，这是因为除IE8及更早版本外的所有主流浏览器都原生支持。主、中、副键的定义非常明确，而IE定义的其他情形都可以翻译为按下其中某个键，而且优先翻译为主键。比如，IE返回5或7时，就会对应到DOM的0。

            7. 额外事件信息
               DOM2 Events规范在event对象上提供了detail属性，以给出关于事件的更多信息。对鼠标事件来说，detail包含一个数值，表示在给定位置上发生了多少次单击。单击相当于在同一个像素上发生一次mousedown紧跟一次mouseup。detail的值从1开始，每次单击会加1。如果鼠标在mousedown和mouseup之间移动了，则detail会重置为0。
               IE还为每个鼠标事件提供了以下额外信息：

               - altLeft，布尔值，表示是否按下了左Alt键（如果altLeft是true，那么altKey也是true）；
               - ctrlLeft，布尔值，表示是否按下了左Ctrl键（如果ctrlLeft是true，那么ctrlKey也是true）；
               - offsetX，光标相对于目标元素边界的x坐标；
               - offsetY，光标相对于目标元素边界的y坐标；
               - shiftLeft，布尔值，表示是否按下了左Shift键（如果shiftLeft是true，那么shiftKey也是true）。

               这些属性的作用有限，这是因为只有IE支持。而且，它们提供的信息要么没必要，要么可以通过其他方式计算。

            8. mousewheel事件
               IE6首先实现了mousewheel事件。之后，Opera、Chrome和Safari也跟着实现了。mousewheel事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。这个事件会在任何元素上触发，并（在IE8中）冒泡到document和（在所有现代浏览器中）window。mousewheel事件的event对象包含鼠标事件的所有标准信息，此外还有一个名为wheelDelta的新属性。当鼠标滚轮向前滚动时，wheelDelta每次都是+120；而当鼠标滚轮向后滚动时，wheelDelta每次都是–120。

            9. 触摸屏设备
               iOS和Android等触摸屏设备的实现大相径庭，因为触摸屏通常不支持鼠标操作。在为触摸屏设备开发时，要记住以下事项。

               - 不支持dblclick事件。双击浏览器窗口可以放大，但没有办法覆盖这个行为。
               - 单指点触屏幕上的可点击元素会触发mousemove事件。如果操作会导致内容变化，则不会再触发其他事件。如果屏幕上没有变化，则会相继触发mousedown、mouseup和click事件。点触不可点击的元素不会触发事件。可点击元素是指点击时有默认动作的元素（如链接）或指定了onclick事件处理程序的元素。
               - mousemove事件也会触发mouseover和mouseout事件。
               - 双指点触屏幕并滑动导致页面滚动时会触发mousewheel和scroll事件。

            10. 无障碍问题
               如果Web应用或网站必须考虑残障人士，特别是使用屏幕阅读器的用户，那么必须小心使用鼠标事件。如前所述，按回车键可以触发click事件，但其他鼠标事件不能通过键盘触发。因此，建议不要使用click事件之外的其他鼠标事件向用户提示功能或触发代码执行，这是因为其他鼠标事件会严格妨碍盲人或视障用户使用。以下是几条使用鼠标事件时应该遵循的无障碍建议。

               - 使用click事件执行代码。有人认为，当使用onmousedown执行代码时，应用程序会运行得更快。对视力正常用户来说确实如此。但在屏幕阅读器上，这样会导致代码无法执行，这是因为屏幕阅读器无法触发mousedown事件。
               - 不要使用mouseover向用户显示新选项。同样，原因是屏幕阅读器无法触发mousedown事件。如果必须要通过这种方式显示新选项，那么可以考虑显示相同信息的键盘快捷键。
               - 不要使用dblclick执行重要的操作，这是因为键盘不能触发这个事件。

         4. 键盘与输入事件
            键盘事件是用户操作键盘时触发的。DOM2 Events最初定义了键盘事件，但该规范在最终发布前删除了相应内容。因此，键盘事件很大程度上是基于原始的DOM0实现的。

            DOM3 Events为键盘事件提供了一个首先在IE9中完全实现的规范。其他浏览器也开始实现该规范，但仍然存在很多遗留的实现。

            键盘事件包含3个事件：

            - keydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。
            - keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc键也会触发这个事件。DOM3 Events废弃了keypress事件，而推荐textInput事件。
            - keyup，用户释放键盘上某个键时触发。

            虽然所有元素都支持这些事件，但当用户在文本框中输入内容时最容易看到。

            输入事件只有一个，即textInput。这个事件是对keypress事件的扩展，用于在文本显示给用户之前更方便地截获文本输入。textInput会在文本被插入到文本框之前触发。

            当用户按下键盘上的某个字符键时，首先会触发 keydown 事件，然后触发 keypress 事件，最后触发 keyup 事件。注意，这里 keydown 和 keypress 事件会在文本框出现变化之前触发，而 keyup 事件会在文本框出现变化之后触发。如果一个字符键被按住不放，keydown 和 keypress 就会重复触发，直到这个键被释放。

            对于非字符键，在键盘上按一下这个键，会先触发 keydown 事件，然后触发 keyup 事件。如果按住某个非字符键不放，则会重复触发 keydown 事件，直到这个键被释放，此时会触发 keyup 事件。

            1. 键码
               对于keydown和keyup事件，event对象的keyCode属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键，keyCode的值与小写字母和数字的ASCII编码一致。比如数字7键的keyCode为55，而字母A键的keyCode为65，而且跟是否按了Shift键无关。DOM和IE的event对象都支持keyCode属性。

            2. 字符编码
               在keypress事件发生时，意味着按键会影响屏幕上显示的文本。对插入或移除字符的键，所有浏览器都会触发keypress事件，其他键则取决于浏览器。因为DOM3 Events规范才刚刚开始实现，所以不同浏览器之间的实现存在显著差异。

               浏览器在event对象上支持charCode属性，只有发生keypress事件时这个属性才会被设置值，包含的是按键字符对应的ASCII编码。通常，charCode属性的值是0，在keypress事件发生时则是对应按键的键码。IE8及更早版本和Opera使用keyCode传达字符的ASCII编码。

            3. DOM3的变化
               尽管所有浏览器都实现了某种形式的键盘事件，DOM3 Events还是做了一些修改。比如，DOM3 Events规范并未规定charCode属性，而是定义了key和char两个新属性。

               其中，key属性用于替代keyCode，且包含字符串。在按下字符键时，key的值等于文本字符（如“k”或“M”）；在按下非字符键时，key的值是键名（如“Shift”或“ArrowDown”）。char属性在按下字符键时与key类似，在按下非字符键时为null。

               DOM3 Events也支持一个名为location的属性，该属性是一个数值，表示是在哪里按的键。可能的值为：0是默认键，1是左边（如左边的Alt键），2是右边（如右边的Shift键），3是数字键盘，4是移动设备（即虚拟键盘），5是游戏手柄（如任天堂Wii控制器）。IE9支持这些属性。Safari和Chrome支持一个等价的keyLocation属性，但由于实现有问题，这个属性值始终为0，除非是数字键盘（此时值为3），值永远不会是1、2、4、5。

               与key属性类似，location属性也没有得到广泛支持，因此不建议在跨浏览器开发时使用。

               最后一个变化是给event对象增加了getModifierState()方法。这个方法接收一个参数，一个等于Shift、Control、Alt、AltGraph或Meta的字符串，表示要检测的修饰键。如果给定的修饰键处于激活状态（键被按住），则方法返回true，否则返回false。当然，event对象已经通过shiftKey、altKey、ctrlKey和metaKey属性暴露了这些信息。

            4. textInput事件
               DOM3 Events规范增加了一个名为textInput的事件，其在字符被输入到可编辑区域时触发。作为对keypress的替代，textInput事件的行为有些不一样。一个区别是keypress会在任何可以获得焦点的元素上触发，而textInput只在可编辑区域上触发。另一个区别是textInput只在有新字符被插入时才会触发，而keypress对任何可能影响文本的键都会触发（包括退格键）。

               因为textInput事件主要关注字符，所以在event对象上提供了一个data属性，包含要插入的字符（不是字符编码）。data的值始终是要被插入的字符，因此如果在按S键时没有按Shift键，data的值就是"s"，但在按S键时同时按Shift键，data的值则是"S"。

               event对象上还有一个名为inputMethod的属性，该属性表示向控件中输入文本的手段。可能的值如下：
               - 0，表示浏览器不能确定是什么输入手段；
               - 1，表示键盘；
               - 2，表示粘贴；
               - 3，表示拖放操作；
               - 4，表示IME；
               - 5，表示表单选项；
               - 6，表示手写（如使用手写笔）；
               - 7，表示语音；
               - 8，表示组合方式；
               - 9，表示脚本。

            5. 设备上的键盘事件
               任天堂Wii会在用户按下Wii遥控器上的键时触发键盘事件。虽然不能访问Wii遥控器上所有的键，但其中一些键可以触发键盘事件。

         5. 合成事件
            合成事件是DOM3 Events中新增的，用于处理通常使用IME输入时的复杂输入序列。IME可以让用户输入物理键盘上没有的字符。例如，使用拉丁字母键盘的用户还可以使用IME输入日文。IME通常需要同时按下多个键才能输入一个字符。合成事件用于检测和控制这种输入。合成事件有以下3种：

            - compositionstart，在IME的文本合成系统打开时触发，表示输入即将开始；
            - compositionupdate，在新字符插入输入字段时触发；
            - compositionend，在IME的文本合成系统关闭时触发，表示恢复正常键盘输入。

            合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是data，其中包含的值视情况而异：

            - 在compositionstart事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换）；
            - 在compositionupdate事件中，包含要插入的新字符；
            - 在compositionend事件中，包含本次合成过程中输入的全部内容。

            与文本事件类似，合成事件可以用来在必要时过滤输入内容。

         6. 变化事件
            DOM2的变化事件（Mutation Events）是为了在DOM发生变化时提供通知。

         7. HTML5事件
            DOM规范并未涵盖浏览器都支持的所有事件。很多浏览器根据特定的用户需求或使用场景实现了自定义事件。HTML5详尽地列出了浏览器支持的所有事件。本节讨论HTML5中得到浏览器较好支持的一些事件。注意这些并不是浏览器支持的所有事件。（本书后面也会涉及一些其他事件。）

            1. contextmenu事件
               Windows 95通过单击鼠标右键为PC用户增加了上下文菜单的概念。不久，这个概念也在Web上得以实现。开发者面临的问题是如何确定何时该显示上下文菜单（在Windows上是右击鼠标，在Mac上是Ctrl+单击），以及如何避免默认的上下文菜单起作用。结果就出现了contextmenu事件，以专门用于表示何时该显示上下文菜单，从而允许开发者取消默认的上下文菜单并提供自定义菜单。

               contextmenu事件冒泡，因此只要给document指定一个事件处理程序就可以处理页面上的所有同类事件。事件目标是触发操作的元素。这个事件在所有浏览器中都可以取消，在DOM合规的浏览器中使用event.preventDefault()，在IE8及更早版本中将event.returnValue设置为false。contextmenu事件应该算一种鼠标事件，因此event对象上的很多属性都与光标位置有关。通常，自定义的上下文菜单都是通过oncontextmenu事件处理程序触发显示，并通过onclick事件处理程序触发隐藏的。

            2. beforeunload事件
               beforeunload事件会在window上触发，用意是给开发者提供阻止页面被卸载的机会。这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。相反，这个事件会向用户显示一个确认框，其中的消息表明浏览器即将卸载页面，并请用户确认是希望关闭页面，还是继续留在页面上。

            3. DOMContentLoaded事件
               window的load事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而DOMContentLoaded事件会在DOM树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS文件或其他资源加载完成。相对于load事件，DOMContentLoaded可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。

               要处理DOMContentLoaded事件，需要给document或window添加事件处理程序（实际的事件目标是document，但会冒泡到window）。

            4. readystatechange事件
               IE首先在DOM文档的一些地方定义了一个名为readystatechange事件。这个有点神秘的事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。支持readystatechange事件的每个对象都有一个readyState属性，该属性具有一个以下列出的可能的字符串值。

               - uninitialized：对象存在并尚未初始化。
               - loading：对象正在加载数据。
               - loaded：对象已经加载完数据。
               - interactive：对象可以交互，但尚未加载完成。
               - complete：对象加载完成。

            5. pageshow与pagehide事件
               Firefox和Opera开发了一个名为往返缓存（bfcache，back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。这个缓存不仅存储页面数据，也存储DOM和JavaScript状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发load事件。通常，这不会导致什么问题，因为整个页面状态都被保存起来了。不过，Firefx决定提供一些事件，把往返缓存的行为暴露出来。

               第一个事件是pageshow，其会在页面显示时触发，无论是否来自往返缓存。在新加载的页面上，pageshow会在load事件之后触发；在来自往返缓存的页面上，pageshow会在页面状态完全恢复后触发。注意，虽然这个事件的目标是document，但事件处理程序必须添加到window上。

            6. hashchange事件
               HTML5增加了hashchange事件，用于在URL散列值（URL最后#后面的部分）发生变化时通知开发者。这是因为开发者经常在Ajax应用程序中使用URL散列值存储状态信息或路由导航信息。

               onhashchange事件处理程序必须添加给window，每次URL散列值发生变化时会调用它。event对象有两个新属性：oldURL和newURL。这两个属性分别保存变化前后的URL，而且是包含散列值的完整URL。

         8. 设备事件
            随着智能手机和平板计算机的出现，用户与浏览器交互的新方式应运而生。为此，一批新事件被发明了出来。设备事件可以用于确定用户使用设备的方式。W3C在2011年就开始起草一份新规范，用于定义新设备及设备相关的事件。

            1. orientationchange事件
               苹果公司在移动Safari浏览器上创造了orientationchange事件，以方便开发者判断用户的设备是处于垂直模式还是水平模式。移动Safari在window上暴露了window.orientation属性，它有以下3种值之一：0表示垂直模式，90表示左转水平模式（主屏幕键在右侧），–90表示右转水平模式（主屏幕键在左）。虽然相关文档也提及设备倒置后的值为180，但设备本身至今还不支持。

            2. deviceorientation事件
               deviceorientation是DeviceOrientationEvent规范定义的事件。如果可以获取设备的加速计信息，而且数据发生了变化，这个事件就会在window上触发。要注意的是，deviceorientation事件只反映设备在空间中的朝向，而不涉及移动相关的信息。

            3. devicemotion事件
               DeviceOrientationEvent规范也定义了devicemotion事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。例如，devicemotion事件可以用来确定设备正在掉落或者正拿在一个行走的人手里。

               当devicemotion事件触发时，event对象中包含如下额外的属性。
               - acceleration：对象，包含x、y和z属性，反映不考虑重力情况下各个维度的加速信息。
               - accelerationIncludingGravity：对象，包含x、y和z属性，反映各个维度的加速信息，包含z轴自然重力加速度。
               - interval：毫秒，距离下次触发devicemotion事件的时间。此值在事件之间应为常量。
               - rotationRate：对象，包含alpha、beta和gamma属性，表示设备朝向。

         9. 触摸及手势事件
            Safari为iOS定制了一些专有事件，以方便开发者。因为iOS设备没有鼠标和键盘，所以常规的鼠标和键盘事件不足以创建具有完整交互能力的网页。同时，WebKit也为Android定制了很多专有事件，成为了事实标准，并被纳入W3C的Touch Events规范。本节介绍的事件只适用于触屏设备。

            1. 触摸事件
               iPhone 3G发布时，iOS 2.0内置了新版本的Safari。这个新的移动Safari支持一些与触摸交互有关的新事件。后来的Android浏览器也实现了同样的事件。当手指放在屏幕上、在屏幕上滑动或从屏幕移开时，触摸事件即会触发。触摸事件有如下几种。

               - touchstart：手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。
               - touchmove：手指在屏幕上滑动时连续触发。在这个事件中调用preventDefault()可以阻止滚动。
               - touchend：手指从屏幕上移开时触发。
               - touchcancel：系统停止跟踪触摸时触发。文档中并未明确什么情况下停止跟踪。

               这些事件都会冒泡，也都可以被取消。尽管触摸事件不属于DOM规范，但浏览器仍然以兼容DOM的方式实现了它们。因此，每个触摸事件的event对象都提供了鼠标事件的公共属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。

               除了这些公共的DOM属性，触摸事件还提供了以下3个属性用于跟踪触点。

               - touches：Touch对象的数组，表示当前屏幕上的每个触点。
               - targetTouches：Touch对象的数组，表示特定于事件目标的触点。
               - changedTouches：Touch对象的数组，表示自上次用户动作之后变化的触点。

               每个Touch对象都包含下列属性。
               - clientX：触点在视口中的x坐标。
               - clientY：触点在视口中的y坐标。
               - identifier：触点ID。
               - pageX：触点在页面上的x坐标。
               - pageY：触点在页面上的y坐标。
               - screenX：触点在屏幕上的x坐标。
               - screenY：触点在屏幕上的y坐标。
               - target：触摸事件的事件目标。

               这些事件会在文档的所有元素上触发，因此可以分别控制页面的不同部分。当手指点触屏幕上的元素时，依次会发生如下事件（包括鼠标事件）：
               (1) touchstart

               (2) mouseover

               (3) mousemove（1次）

               (4) mousedown

               (5) mouseup

               (6) click

               (7) touchend

            2. 手势事件
               iOS 2.0中的Safari还增加了一种手势事件。手势事件会在两个手指触碰屏幕且相对距离或旋转角度变化时触发。手势事件有以下3种。
               gesturestart：一个手指已经放在屏幕上，再把另一个手指放到屏幕上时触发。
               gesturechange：任何一个手指在屏幕上的位置发生变化时触发。
               gestureend：其中一个手指离开屏幕时触发。

               只有在两个手指同时接触事件接收者时，这些事件才会触发。在一个元素上设置事件处理程序，意味着两个手指必须都在元素边界以内才能触发手势事件（这个元素就是事件目标）。因为这些事件会冒泡，所以也可以把事件处理程序放到文档级别，从而可以处理所有手势事件。使用这种方式时，事件的目标就是两个手指均位于其边界内的元素。

               触摸事件和手势事件存在一定的关系。当一个手指放在屏幕上时，会触发touchstart事件。当另一个手指放到屏幕上时，gesturestart事件会首先触发，然后紧接着触发这个手指的touchstart事件。如果两个手指或其中一个手指移动，则会触发gesturechange事件。只要其中一个手指离开屏幕，就会触发gestureend事件，紧接着触发该手指的touchend事件。

               与触摸事件类似，每个手势事件的event对象都包含所有标准的鼠标事件属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。新增的两个event对象属性是rotation和scale。rotation属性表示手指变化旋转的度数，负值表示逆时针旋转，正值表示顺时针旋转（从0开始）。scale属性表示两指之间距离变化（对捏）的程度。开始时为1，然后随着距离增大或缩小相应地增大或缩小。

         10. 事件参考
            本节给出了DOM规范、HTML5规范，以及概述事件行为的其他当前已发布规范中定义的所有浏览器事件。这些事件按照API和/或规范分类。

5.  内存与性能
    因为事件处理程序在现代 Web 应用中可以实现交互，所以很多开发者会错误地在页面中大量使用它们。在创建 GUI 的语言如 C#中，通常会给 GUI 上的每个按钮设置一个 onclick 事件处理程序。这样做不会有什么性能损耗。在 JavaScript 中，页面中事件处理程序的数量与页面整体性能直接相关。原因有很多。首先，每个函数都是对象，都占用内存空间，对象越多，性能越差。其次，为指定事件处理程序所需访问 DOM 的次数会先期造成整个页面交互的延迟。只要在使用事件处理程序时多注意一些方法，就可以改善页面性能。

    1. 事件委托
       “过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。例如，click 事件冒泡到 document。这意味着可以为整个页面指定一个 onclick 事件处理程序，而不用为每个可点击元素分别指定事件处理程序。

       只要可行，就应该考虑只给 document 添加一个事件处理程序，通过它处理页面中所有某种类型的事件。相对于之前的技术，事件委托具有如下优点。

       - document 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded 或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。
       - 节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也可以节省时间。
       - 减少整个页面所需的内存，提升整体性能。

       最适合使用事件委托的事件包括：click、mousedown、mouseup、keydown 和 keypress。mouseover 和 mouseout 事件冒泡，但很难适当处理，且经常需要计算元素位置（因为 mouseout 会在光标从一个元素移动到它的一个后代节点以及移出元素之外时触发）。

    2. 删除事件处理程序
       把事件处理程序指定给元素后，在浏览器代码和负责页面交互的 JavaScript 代码之间就建立了联系。这种联系建立得越多，页面性能就越差。除了通过事件委托来限制这种连接之外，还应该及时删除不用的事件处理程序。很多 Web 应用性能不佳都是由于无用的事件处理程序长驻内存导致的。

       导致这个问题的原因主要有两个。第一个是删除带有事件处理程序的元素。比如通过真正的 DOM 方法 removeChild()或 replaceChild()删除节点。最常见的还是使用 innerHTML 整体替换页面的某一部分。这时候，被 innerHTML 删除的元素上如果有事件处理程序，就不会被垃圾收集程序正常清理。

6.  模拟事件
    事件就是为了表示网页中某个有意义的时刻。通常，事件都是由用户交互或浏览器功能触发。事实上，可能很少有人知道可以通过 JavaScript 在任何时候触发任意事件，而这些事件会被当成浏览器创建的事件。这意味着同样会有事件冒泡，因而也会触发相应的事件处理程序。这种能力在测试 Web 应用时特别有用。DOM3 规范指明了模拟特定类型事件的方式。IE8 及更早版本也有自己模拟事件的方式。

    1. DOM 事件模拟
       任何时候，都可以使用 document.createEvent()方法创建一个 event 对象。这个方法接收一个参数，此参数是一个表示要创建事件类型的字符串。在 DOM2 中，所有这些字符串都是英文复数形式，但在 DOM3 中，又把它们改成了英文单数形式。可用的字符串值是以下值之一。

       - "UIEvents"（DOM3 中是"UIEvent"）：通用用户界面事件（鼠标事件和键盘事件都继承自这个事件）。
       - "MouseEvents"（DOM3 中是"MouseEvent"）：通用鼠标事件。
       - "HTMLEvents"（DOM3 中没有）：通用 HTML 事件（HTML 事件已经分散到了其他事件大类中）。

       注意，键盘事件不是在 DOM2 Events 中规定的，而是后来在 DOM3 Events 中增加的。

       创建 event 对象之后，需要使用事件相关的信息来初始化。每种类型的 event 对象都有特定的方法，可以使用相应数据来完成初始化。方法的名字并不相同，这取决于调用 createEvent()时传入的参数。

       事件模拟的最后一步是触发事件。为此要使用 dispatchEvent()方法，这个方法存在于所有支持事件的 DOM 节点之上。dispatchEvent()方法接收一个参数，即表示要触发事件的 event 对象。调用 dispatchEvent()方法之后，事件就“转正”了，接着便冒泡并触发事件处理程序执行。

       1. 模拟鼠标事件
          模拟鼠标事件需要先创建一个新的鼠标 event 对象，然后再使用必要的信息对其进行初始化。要创建鼠标 event 对象，可以调用 createEvent()方法并传入"MouseEvents"参数。这样就会返回一个 event 对象，这个对象有一个 initMouseEvent()方法，用于为新对象指定鼠标的特定信息。initMouseEvent()方法接收 15 个参数，分别对应鼠标事件会暴露的属性。这些参数列举如下。

          - type（字符串）：要触发的事件类型，如"click"。
          - bubbles（布尔值）：表示事件是否冒泡。为精确模拟鼠标事件，应该设置为 true。
          - cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true。
          - view（AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。
          - detail（整数）：关于事件的额外信息。只被事件处理程序使用，通常为 0。
          - screenX（整数）：事件相对于屏幕的 x 坐标。
          - screenY（整数）：事件相对于屏幕的 y 坐标。
          - clientX（整数）：事件相对于视口的 x 坐标。
          - clientY（整数）：事件相对于视口的 y 坐标。
          - ctrlkey（布尔值）：表示是否按下了 Ctrl 键。默认为 false。
          - altkey（布尔值）：表示是否按下了 Alt 键。默认为 false。
          - shiftkey（布尔值）：表示是否按下了 Shift 键。默认为 false。
          - metakey（布尔值）：表示是否按下了 Meta 键。默认为 false。
          - button（整数）：表示按下了哪个按钮。默认为 0。
          - relatedTarget（对象）：与事件相关的对象。只在模拟 mouseover 和 mouseout 时使用。

          显然，initMouseEvent()方法的这些参数与鼠标事件的 event 对象属性是一一对应的。前 4 个参数是正确模拟事件唯一重要的几个参数，这是因为它们是浏览器要用的，其他参数则是事件处理程序要用的。event 对象的 target 属性会自动设置为调用 dispatchEvent()方法时传入的节点。

       2. 模拟键盘事件
          如前所述，DOM2 Events 中没有定义键盘事件，因此模拟键盘事件并不直观。键盘事件曾在 DOM2 Events 的草案中提到过，但最终成为推荐标准前又被删掉了。要注意的是，DOM3 Events 中定义的键盘事件与 DOM2 Events 草案最初定义的键盘事件差别很大。

          在 DOM3 中创建键盘事件的方式是给 createEvent()方法传入参数"KeyboardEvent"。这样会返回一个 event 对象，这个对象有一个 initKeyboardEvent()方法。这个方法接收以下参数。

          - type（字符串）：要触发的事件类型，如"keydown"。
          - bubbles（布尔值）：表示事件是否冒泡。为精确模拟键盘事件，应该设置为 true。
          - cancelable（布尔值）：表示事件是否可以取消。为精确模拟键盘事件，应该设置为 true。
          - view（AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。
          - key（字符串）：按下按键的字符串代码。
          - location（整数）：按下按键的位置。0 表示默认键，1 表示左边，2 表示右边，3 表示数字键盘，4 表示移动设备（虚拟键盘），5 表示游戏手柄。
          - modifiers（字符串）：空格分隔的修饰键列表，如"Shift"。
          - repeat（整数）：连续按了这个键多少次。

          注意，DOM3 Events 废弃了 keypress 事件，因此只能通过上述方式模拟 keydown 和 keyup 事件。

       3. 模拟其他事件
          鼠标事件和键盘事件是浏览器中最常见的模拟对象。不过，有时候可能也需要模拟 HTML 事件。模拟 HTML 事件要调用 createEvent()方法并传入"HTMLEvents"，然后再使用返回对象的 initEvent()方法来初始化。

       4. 自定义 DOM 事件
          DOM3 增加了自定义事件的类型。自定义事件不会触发原生 DOM 事件，但可以让开发者定义自己的事件。要创建自定义事件，需要调用 createEvent("CustomEvent")。返回的对象包含 initCustomEvent()方法，该方法接收以下 4 个参数。
          - type（字符串）：要触发的事件类型，如"myevent"。
          - bubbles（布尔值）：表示事件是否冒泡。
          - cancelable（布尔值）：表示事件是否可以取消。
          - detail（对象）：任意值。作为 event 对象的 detail 属性。

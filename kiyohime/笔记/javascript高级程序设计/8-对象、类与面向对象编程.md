## 对象

ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的
值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未
讨论的原因），可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是
数据或者函数。

### 理解对象

1. 属性的类型
   ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义
   的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用
   两个中括号把特性的名称括起来，比如[[Enumerable]]。
   属性分两种：数据属性和访问器属性。

- 数据属性
  数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4
  个特性描述它们的行为。
  - [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特
    性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特
    性都是 true，如前面的例子所示。
  - [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对
    象上的属性的这个特性都是 true，如前面的例子所示。
  - [[Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的
    这个特性都是 true，如前面的例子所示。
  - [[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性
    的默认值为 undefined。
- 访问器属性
  访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不
  过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效
  的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访
  问器属性有 4 个特性描述它们的行为。
  - [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特
    性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性
    都是 true。
  - [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对
    象上的属性的这个特性都是 true。
  - [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。
  - [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。

2. 定义多个属性
   在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了 Object.defineProperties()方法。
   这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和
   另一个描述符对象，其属性与要添加或修改的属性一一对应。
3. 读取属性的特性
   使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两
   个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 configurable、enumerable、get 和 set 属性，对于数据属性包含 configurable、enumerable、writable 和 value 属性。
4. 合并对象
   JavaScript 开发者经常觉得“合并”（merge）两个对象很有用。更具体地说，就是把源对象所有的
   本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin），因为目标对象通过混入
   源对象的属性得到了增强。
   ECMAScript 6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个
   或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true）
   和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。以字符串和符号为键的属性
   会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标
   对象上的[[Set]]设置属性的值。

5. 对象标识及相等判定
   ECMAScript 6 规范新增了 Object.is()，这个方法与===很像。
6. 增强的对象语法
   ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性。这些特性都没有改变现有引擎
   的行为，但极大地提升了处理对象的方便程度。
   - 属性值简写
     在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。为此，简写属性名语法出现了。简写属性名
     只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。
   - 可计算属性
   - 简写方法名
7. 对象解构
   ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简
   单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。
   - 嵌套解构
   - 部分解构
   - 参数上下文匹配

### 创建对象

1. 概述
   综观 ECMAScript 规范的历次发布，每个版本的特性似乎都出人意料。ECMAScript 5.1 并没有正式
   支持面向对象的结构，比如类或继承。但是，正如接下来几节会介绍的，巧妙地运用原型式继承可以成
   功地模拟同样的行为。
   ECMAScript 6 开始正式支持类和继承。ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模
   式。不过，无论从哪方面看，ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已。
2. 工厂模式
   工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。
3. 构造函数模式
   像 Object 和 Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函
   数，以函数的形式为自己的对象类型定义属性和方法。

### 继承

ECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用
类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有
一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味
着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函
数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。

### 类

不难看出，各种策略都有自己的问题，也有相应的妥协。正因为如此，实现继承的代码也显得非常冗长和混乱。为解决
这些问题，ECMAScript 6 新引入的 class 关键字具有正式定义类的能力。类（class）是 ECMAScript 中新的基础
性语法糖结构，因此刚开始接触时可能会不太习惯。虽然 ECMAScript 6 类表面上看起来可以支持正式的面向对象编
程，但实际上它背后使用的仍然是原型和构造函数的概念。

1. 类定义
   与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 class 关键字加大括号
